# 编译课程设计文档

19373590 郭书阳

### 一、整体架构

​		整体上采用前后端分离的架构，前端主要由词法分析、语法分析、错误处理、符号表管理、中间代码生成几部分组成，词法分析器从输入文件中不断读入字符形成单词并提供给语法分析器，语法分析器进行递归下降的语法成分分析并同步进行错误探测与处理和填读符号表操作，同时针对各语句生成相应的四元式中间代码。后端主要由目标代码生成和代码优化两部分组成，后端从前端生成的中间代码开始，首先构造记录各变量内存偏移量的后端符号表，再对中间代码进行多遍扫描以进行优化和目标代码生成。有图示如下：

![image-20211129091907527](C:\Users\w\AppData\Roaming\Typora\typora-user-images\image-20211129091907527.png)

​		某些关键实体定义如下：

​		**单词**：由词法分析部分输出，交由语法分析进一步处理。

```c++
struct Word {
    string code;			//单词符号
    string content;			//单词内容
    int line;				//行数位置
};
```

​		**符号**：前端在语法分析部分输出，填入前端符号表，之后可用于中间代码生成与错误处理。后端则将中间代码中所带的符号填入后端符号表，之后用于生成目标代码时查找对应变量位置。

```c++
//数据基础类型
enum baseType {INT,VOID,NOBASETYPE}; 

//数据类型，包括常量、变量、函数、参数、非函数等
enum dataType {CONST,VAR,FUNC,PARAM,NODATATYPE,NOFUNC}; 

struct Symbol {
    string name;				//变量名
    baseType basetype;			//基础类型
    dataType datatype;			//数据类型
    vector<Symbol> params;		//参数
    int dim;					//维数
    int dim1;					//一维大小，默认为1
    int dim2;					//二维大小，默认为1
    vector<int> constvalue;		//常数值，仅用于前端
    int value;					//非常数值，仅用于后端
    int offset;					//在内存中的偏移量，仅用于后端
    bool pointer;				//是否为指针
};
```

​		**中间代码四元式**：中间代码生成部分输出，交由目标代码生成进一步处理。

```c++
struct MiddleCodeItem
{
    Operator op;				//操作符
    Symbol id1;					//第一个操作数
    Symbol id2;					//第二个
    Symbol id3;					//第三个
};
```

### 二、词法分析

​		**设计前架构**：作为编译器中的一个类，在编译器开始运行时初始化，同时将文件输入流接到这个类上。将整个文件读入一个字符串中再进行后续处理。在类中建立一个容器存储word结构。在算法方面，主要采用有限状态机实现对词汇的读取和识别，状态图则根据文档中给出的词汇表与文法建立。在读完一个词汇之后，通过addlist方法将其信息加入到容器中。

​		**完成后对架构的修改**：大体框架没有改变，但在设计状态图的时候没有考虑到注释，在状态图中添加了注释相关的状态与转移路径。

### 三、语法分析

​		**设计前架构**：作为编译器中的一个类，在编译器开始运行时初始化，将词法分析类初始化后将其作为语法分析类的一部分，每次调用词法分析类的analyze方法都返回一个word，实现词汇的依次读取。由于给定语法并不是LL(1)的，所以要预读2个词以便于判断分支，这里使用数组实现。之后根据给定语法，采用递归下降的分析策略，为每个语法成分写一个分析方法。

​		**完成后对架构的修改**：大体框架没有改变。但有两个bug需要修复：一是在处理AddExp这种左递归的语法时，输出语法成分的位置不对，导致每次输出都会少一个AddExp。二是在stmt的分析中，以lval开头的语句有两种可能的分支，需要判断后续有没有ASSIGN，这个问题最后通过在语法分析中添加一个链式的预读解决。

### 四、错误处理

​		**设计前架构**：因为错误处理需要错误局部化处理，因此将错误处理内嵌到语法分析当中，在语法分析的同时完成错误处理。同时，由于错误不仅仅牵涉到一种语法成分，所以错误处理需要符号表类记录一些符号的内容以便于判断该符号所关联的语法成分是否产生错误。

​		**符号表类架构**：符号表类主体数据结构采用链式结构，共三个部分：全局符号表globalTable，局部符号表数组localTables，当前局部符号表nowlocalTable。对外接口主要有插入、查找和处理局部符号表三类。其中插入为insert方法与changeDimType方法，查找为find/get一类方法，处理局部符号表则包括addNewLocalTable方法和removeNowLocalTable方法。

​		**完成后对架构的修改**：问题主要出在c类错误和g类错误。在判断c类错误时，由于我并未区分函数block与语句block，导致在将函数参数读进符号表之后，读到函数block就调用addNewLocalTable方法，将含有参数的局部符号表存入了localTables，当前局部符号表为空，之后在函数体内部调用参数变量时就会报c类错误。g类错误则是因为没有考虑main函数的return语句。

### 五、中间代码生成

​		**设计前架构**：中间代码的四元式定义如下：

|        操作符op         |      id1      |   id2    |   id3    |         语义         |
| :---------------------: | :-----------: | :------: | :------: | :------------------: |
|  Add,Minus,Mul,Div,Mod  |   左操作数    | 右操作数 | 结果符号 |       算术运算       |
|         GetInt          |   结果符号    |          |          |         输入         |
|         Printf          |  待输出符号   |          |          |         输出         |
|         Declare         | 常量/变量符号 |          |          |    声明常量/变量     |
|         Assign          |  被赋值符号   | 赋值符号 |          |         赋值         |
|        ArrayGet         |   数组符号    |   下标   | 结果符号 |      取数组元素      |
|      ArrayGetArray      |   数组符号    |   下标   | 结果符号 |      取数组地址      |
|       ArrayAssign       |   数组符号    |   下标   | 赋值符号 |     赋值数组元素     |
|       FuncDeclare       |   函数符号    |          |          |       声明函数       |
|        FuncCall         |   函数符号    | 结果符号 |          |       调用函数       |
|       FuncReturn        |  返回值符号   |          |          |       函数返回       |
|        PushParam        |   参数符号    |          |          |     声明函数参数     |
|       BlockBegin        |               |          |          |      语句块开始      |
|        BlockEnd         |               |          |          |      语句块结束      |
| Lss,Leq,Gre,Geq,Eql,Neq |   左操作数    | 右操作数 |   结果   |       逻辑运算       |
|           Not           |    操作数     |   结果   |          |       逻辑运算       |
|         Beq,Bne         |    操作数     | 标签符号 |          | 逻辑运算与有条件跳转 |
|          Label          |   标签符号    |          |          |       新增标签       |
|          Jump           |   标签符号    |          |          |      无条件跳转      |

​		其中需要注意的有两点：一是对数组一律视为一维数组处理，二维数组的元素在处理时要计算出对应一维数组元素的下标。二是在语法分析过程中，使用了全局变量nowsymbol，储存了每个语法成分分析完之后，该语法成分对应的符号，相当于储存中间变量。

​		**完成后对架构的修改**：第一版的中间代码设计中有And和Or，通过计算逻辑表达式的值判断条件跳转，未能够实现可靠的短路判断。在第二版中改成了Beq和Bne，Beq仅用于&&的判断，如果&&前的逻辑表达式为假，即Beqz，则将这个逻辑表达式的值储存为当前&&所在的LAndExp表达式的值并跳转。同理，Bne仅用于||的判断，如果||前的LAndExp表达式为真，即Bnez，则跳转。LAndExp类型表达式值的存储在目标代码生成中处理。

### 六、目标代码生成

​		**设计前架构**：处理顺序如下：先处理所有待输出字符串，生成.data段，再处理全局变量，再处理每个函数。

​		在寄存器分配方面，$s0-$s7存储函数参数，$t0-$t2供中间代码中的三个操作数临时使用，$t3-$t8供临时变量存储，$t9供条件判断操作临时使用，$v0存返回值，$ra存返回地址。

​		在内存分配方面，将全局变量分配到$gp，局部变量分配到$sp，并给每个变量一个相对于$gp或当前函数$sp的偏移量存入offset。处理中间代码时，就要根据操作数名寻找该操作数在内存中的偏移量，由此需要使用的后端符号表与前端符号表类似，不再详述。

​		**完成后对架构的修改**：$t9的使用是基于中间代码生成中对于架构的修改，$t9存储当前LAndExp类型表达式值。此外在函数调用时，不仅需要保存$s0-$s7寄存器和当前的$sp和当前的$ra，当前的$t3-$t8寄存器也要保存，这一点没有考虑到。另外还有当函数参数为数组时，传入的实参原本就是数组地址的情况，这种情况直接将作为实参的指针的值赋给函数参数就行了。

### 七、代码优化

​		代码优化部分仅实现了$t3-$t8寄存器的刷新。在计算表达式时，会产生很多中间变量符号，将中间变量符号存储到$t3-$t8寄存器后，一旦该符号被使用，就意味着其已经完成任务，将其所在寄存器刷新。
